<html><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<TITLE>1.htm</TITLE>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=WINDOWS-1251">
<META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">

<STYLE>
</STYLE>
</HEAD>

<body background="fon.jpg" tppabs="http://orloff.am.tpu.ru/matlab/Append/Info/fon.jpg">
<ul>
  <li><b><font face="Times New Roman CYR" size=3><a href="#1">Урок 20. Основы 
    программирования </a></font></b> </li>
  <ul>
    <li><font face="Times New Roman CYR" size=3><a href="#2">Основные понятия 
      программирования </a></font> 
      <ul>
        <li><font face="Times New Roman CYR" size=3><a href="#3">Основные средства 
          программирования</a></font> </li>
        <li><font face="Times New Roman CYR" size=3><a href="#4">Основные типы 
          данных </a></font> </li>
        <li><font face="Times New Roman CYR" size=3><a href="#5">Виды программирования</a></font> 
        </li>
      </ul>
    </li>
    <li><font face="Times New Roman CYR" size=3><a href="#6">Двойственность операторов, 
      команд и функций </a></font> 
      <ul>
        <li><font face="Times New Roman CYR" size=3><a href="#7">Некоторые ограничения</a></font> 
        </li>
      </ul>
    </li>
    <li><font face="Times New Roman CYR" size=3><a href="#8">М-файлы сценариев 
      и функций</a></font> </li>
    <ul>
      <li><font face="Times New Roman CYR" size=3><a href="#9">Структура и свойства 
        файлов сценариев </a></font> </li>
      <li><font face="Times New Roman CYR" size=3><a href="#10">Статус переменных 
        в функциях </a></font> </li>
      <li><font face="Times New Roman CYR" size=3><a href="#11">Структура М-файла-функции 
        </a></font> </li>
      <li><font face="Times New Roman CYR" size=3><a href="#12">Статус переменных 
        и команда global</a></font> </li>
      <li><font face="Times New Roman CYR" size=3><a href="#13">Использование 
        подфункций </a></font> </li>
      <li><font face="Times New Roman CYR" size=3><a href="#14">Частные каталоги 
        </a></font> </li>
    </ul>
    <li><font face="Times New Roman CYR" size=3><a href="#15">Обработка ошибок 
      </a></font> 
      <ul>
        <li><font face="Times New Roman CYR" size=3><a href="#16">Вывод сообщений 
          об ошибках </a></font> </li>
        <li><font face="Times New Roman CYR" size=3><a href="#17">Функция lasterr 
          и обработка ошибок </a></font> </li>
      </ul>
    </li>
    <li><font face="Times New Roman CYR" size=3><a href="#18">Функции с переменным 
      числом аргументов </a></font> 
      <ul>
        <li><font face="Times New Roman CYR" size=3><a href="#19">Функции подсчета 
          числа аргументов </a></font> </li>
        <li><font face="Times New Roman CYR" size=3><a href="#20">Переменные varargin 
          и varargout </a></font> </li>
      </ul>
    </li>
    <li><font face="Times New Roman CYR" size=3><a href="#21">Комментарии </a></font> 
    </li>
    <li><font face="Times New Roman CYR" size=3><a href="#22">Особенности выполнения 
      m-файлов функций </a></font> </li>
    <li><font face="Times New Roman CYR" size=3><a href="#23">Создание Р-кодов 
      </a></font> </li>
    <li><font face="Times New Roman CYR" size=3><a href="#24">Управляющие структуры 
      </a></font> 
      <ul>
        <li><font face="Times New Roman CYR" size=3><a href="#25">Диалоговый ввод 
          </a></font> </li>
        <li><font face="Times New Roman CYR" size=3><a href="#26">Условный оператор 
          </a></font> </li>
        <li><font face="Times New Roman CYR" size=3><a href="#27">Циклы типа for...end 
          </a></font> </li>
        <li><font face="Times New Roman CYR" size=3><a href="#28">Циклы типа while...end 
          </a></font> </li>
        <li><font face="Times New Roman CYR" size=3><a href="#29">Конструкция 
          переключателя </a></font> </li>
        <li><font face="Times New Roman CYR" size=3><a href="#10">Конструкция 
          try...catch...end</a></font> </li>
        <li><font face="Times New Roman CYR" size=3><a href="#31">Создание паузы 
          в вычислениях </a></font> </li>
      </ul>
    </li>
    <li><font face="Times New Roman CYR" size=3><a href="#32">Понятие об объектно-ориентированном 
      программировании </a></font> 
      <ul>
        <li><font face="Times New Roman CYR" size=3><a href="#33">Создание класса 
          или объекта</a></font> </li>
        <li><font face="Times New Roman CYR" size=3><a href="#34">Проверка принадлежности 
          объекта к заданному классу </a></font> </li>
        <li><font face="Times New Roman CYR" size=3><a href="#35">Другие функции 
          объектно-ориентированного программирования </a></font> </li>
      </ul>
    </li>
    <li><font face="Times New Roman CYR" size=3><a href="#36">Что нового мы узнали? 
      </a></font> </li>
  </ul>
</ul>


<A NAME="1"></A> 
<P align="left"><font face="Times New Roman, Times, serif" size="2"><b><font size="3">Урок 
  №20.</font></b></font> </P>
<P align="left"><font face="Times New Roman" size="5">Основы программирования</font> 
</P>
<ul>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Основные понятия программирования</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Основные типы данных</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Двойственность операторов, команд</font>
    <font face="Times New Roman" size="3">и функций</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Структура и свойства файлов сценариев&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Структура и свойства файлов функций&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Статус переменных&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Использование подфункций&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Обработка ошибок&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Функции с переменным числом</font>
    <font face="Times New Roman" size="3">аргументов&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Создание Р-кодов&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Управляющие структуры&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Диалоговый ввод&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Условный оператор и циклы&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Переключатели&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">    Средства объектно-ориентированного
    </font><font face="Times New Roman" size="3">программирования</font></li>
</ul>
<P align="left"> <B><font face="Times New Roman" size="4"><a name="2"></a>Основные 
  понятия программирования</font></B> </P>
<P align="left">
<font face="Times New Roman" size="3">До сих пор мы в основном использовали систему MATLAB в режиме непосредственного счета — <I>в командном режиме. </I>Однако при решении серьезных задач возникает необходимость сохранения используемых последовательностей вычислений, а также их дальнейшей модификации. Иными словами, существует необходимость <I>программирования </I>решения задач.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Это может показаться отходом от важной цели, которая преследуется разработчиками большинства математических систем, — выполнения математических вычислений без использования традиционного программирования. Однако это не так. Выше было показано, что множество математических задач решается в системе MATLAB без программирования. С использованием языков высокого уровня для их решения потребовалось бы написать и оттестировать сотни программ.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Практически невозможно предусмотреть в одной, даже самой большой и мощной, математической системе возможность решения всех задач, которые могут интересовать пользователя. Программирование в системе MATLAB является эффективным средством ее расширения и адаптации к решению специфических проблем. Оно реализуется с помощью <I>языка программирования </I>системы.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Большинство объектов этого языка, в частности все команды, операторы и функции, одновременно являются объектами <I>входного языка </I>общения с системой в командном режиме работы. Так что фактически мы приступили к описанию языка программирования системы MATLAB с первых строк данной книги.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Так в чем же отличие входного языка от языка программирования? В основном — в способе фиксации создаваемых ими кодов. Сессии в командном режиме работы не сохраняются в памяти компьютера (ведение дневника не в счет). Хранятся только определения созданных в ходе их выполнения переменных и функций. А вот программы на языке программирования MATLAB сохраняются в виде текстовых m-файлов. При этом могут сохраняться как целые программы в виде файлов-сценариев, так и отдельные <I>программные модули — </I>функции. Кроме того, важно, что программа может менять структуру алгоритмов вычислений в зависимости от входных данных и данных, создаваемых в ходе вычислений.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">С позиций программиста язык программирования системы является типичным <I>проблемно-ориентированным </I>языком программирования высокого уровня. Точнее говоря, это даже язык <I>сверхвысокого </I>уровня, содержащий сложные операторы и функции, реализация которых на обычных языках (например, Бейсике, Паскале или Си) потребовала бы много усилий и времени. К таким функциям относятся матричные функции, функции быстрого преобразования Фурье (БПФ) и др.,</font>
<font face="Times New Roman" size="3">а к операторам — операторы построения разнообразных графиков, генерации матриц определенного вида и т. д.</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="3"></a>Основные 
  средства программирования</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Итак, программами в системе MATLAB являются m-файлы текстового формата, содержащие запись программ в виде программных кодов. Язык программирования системы MATLAB имеет следующие средства:</font>
</P>
<ul>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> данные различного типа;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> константы и переменные;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> операторы, включая операторы математических выражений;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> встроенные команды и функции;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> функции пользователя;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">управляющие структуры;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> системные операторы и функции;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> средства расширения языка.</font></li>
</ul>
<P align="left">
<font face="Times New Roman" size="3">Коды программ в системе MATLAB пишутся на языке высокого уровня, достаточно понятном для пользователей умеренной квалификации в области программирования. Язык программирования MATLAB является типичным <I>интерпретатором. </I>Это означает, что каждая инструкция программы распознается и тут же исполняется, что облегчает обеспечение диалогового режима общения с системой. Этап компиляции всех инструкций, т. е. полной программы, отсутствует. Высокая скорость выполнения программ обеспечена наличием заведомо откомпилированного ядра, хранящего в себе критичные к скорости выполнения инструкции, такие как базовые математические и иные функции, а также тщательной отработкой системы контроля синтаксиса программ в режиме интерпретации.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Интерпретация означает, что MATLAB не создает исполняемых конечных программ. Они существуют лишь в виде m-файлов. Для выполнения программ необходима среда MATLAB. Однако для программ на языке MATLAB созданы компиляторы, транслирующие программы MATLAB в коды языков программирования С и C++. Это решает задачу создания исполняемых программ, первоначально разрабатываемых в среде MATLAB. Компиляторы для системы MATLAB являются вполне самостоятельными программными средствами и в данной книге не рассматриваются.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Следует особо отметить, что не все инструкции MATLAB могут компилироваться, так что перед компиляцией программы нуждаются в некоторой доработке. Зато скорость выполнения откомпилированных программ порой возрастает в 10-15 раз (правда, это достигается, как правило, для простых примеров с большими циклами).</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Начальное представление о переменных, встроенных константах и функциях уже было дано в предшествующих главах. В этой главе эти представления будут существенно расширены с позиций пользователя-программиста.</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="4"></a>Основные 
  типы данных</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Структура типов данных системы MATLAB представлена ниже:</font>
</P>
<P align="left"> <font face="Times New Roman" size="3">Типы данных array и numeric 
  являются <I>виртуальными </I>(&laquo;кажущимися&raquo;), поскольку к ним нельзя 
  отнести какие-либо переменные. Они служат для определения и комплектования некоторых 
  типов данных. Таким образом, в MATLAB определены следующие основные типы данных, 
  в общем случае представляющих собой многомерные массивы:</font> </P>
<ul>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> single — числовые массивы с числами одинарной точности;&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> double — числовые массивы с числами удвоенной точности;&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> char — строчные массивы с элементами-символами;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">sparse — наследует свойства double, разреженные матрицы с элементами-числами удвоенной точности;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">сеll — массивы ячеек; ячейки, в свою очередь, тоже могут быть массивами;&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> struct — массивы структур с полями, которые также могут содержать массивы;&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">function_handle — дескрипторы функций:</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> int32, uint32  — массивы 32-разрядных чисел со знаком и без знаков;&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> intl6,uint!6 — массивы 16-разрядных целых чисел со знаком и без знаков;&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> int8. uint8 — массивы 8-разрядных целых чисел со знаками и без знаков.</font></li>
</ul>
<P align="left">
<font face="Times New Roman" size="3">Кроме того, предусмотрен еще один тип данных — UserObject, который относится к типам данных (объектом), определяемым пользователем. Типы данных double, char и sparse были рассмотрены ранее, так что в этой главе будут детально рассмотрены оставшиеся типы. Что касается чисел класса uint8, то они представляют значения от 0 до 255 и занимают в памяти 1/8 часть от размера одного числа с двойной точностью. В основном этот тип данных применяется в служебных целях.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Каждому типу данных можно соотнести некоторые характерные для него операции, называемые <I>методами. </I>Дочерние типы данных, расположенные на приведенной диаграмме ниже родительских типов, наследуют от последних их методы, что является признаком наследования объектов. Поскольку в иерархии типов данных сверху находятся данные типа array, это значит, что все виды данных в MATLAB являются массивами.</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="5"></a>Виды программирования</font> 
</P>
<P align="left">
<font face="Times New Roman" size="3">На рынке программного обеспечения система MATLAB позиционируется как язык высокого уровня для научно-технических расчетов. Таким образом, возможность программирования относится к важным достоинствам данного языка, несмотря на обилие средств прямого решения задач. И действительно, именно возможность программирования сложных задач и практически неограниченного расширения системы сделала MATLAB столь почитаемой системой в университетах и крупных научных учреждениях. MATLAB открывает широчайшие возможности реализации новых алгоритмов вычислений, численных методов и методик расчета и проектирования различных систем и устройств.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Язык программирования системы MATLAB вобрал в себя все средства, необходимые для реализации различных видов программирования:</font>
</P>
<ul>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> процедурного;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> операторного;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> функционального;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> логического;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> структурного (модульного);</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> объектно-ориентированного;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> визуально-ориентированного.</font></li>
</ul>
<P align="left">
<font face="Times New Roman" size="3">В основе <I>процедурного, операторного </I>и <I>функционального </I>типов программирования лежат процедуры, операторы и функции, используемые как основные объекты языка. Эти типы объектов присутствуют в MATLAB. <I>Логическое </I>программирование реализуется в MATLAB с помощью логических операторов и функций. Это позволяет реализовать основные идеи логического программирования, хотя на выдающуюся роль в этом классе языков программирования MATLAB не претендует.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Зато MATLAB представляет собой яркий пример плодотворности <I>структурного </I>программирования. Подавляющее большинство функций и команд языка представляют собой вполне законченные модули, обмен данными между которыми происходит через их входные параметры, хотя возможен обмен информацией и через глобальные переменные. Программные модули оформлены в виде текстовых m-файлов, которые хранятся на диске и подключаются к программам по мере необходимости. Важно отметить, что в отличие от многих языков программирования, применение тех или иных модулей не требует предварительного объявления, а для создания и отладки самостоятельных модулей MATLAB имеет все необходимые средства. Подавляющее большинство команд и функций системы MATLAB поставляется в виде таких модулей.</font>
</P>
<P align="left">
<I><font face="Times New Roman" size="3">Объектно-ориентированное
</font> </I><font face="Times New Roman" size="3">программирование также широко представлено в системе MATLAB. Оно особенно актуально при программировании задач графики. Что качается <I>визуально-ориентированного </I>программирования, то в MATLAB оно представлено в основном в пакете моделирования заданных блоками устройств и систем Simulink. Этот пакет будет рассмотрен в конце книги. В ядре системы в данный момент визуально-ориентированное программирование не используется.</font>
</P>
<P align="left"> <B><font face="Times New Roman" size="4"><a name="6"></a>Двойственность 
  операторов, команд и функций</font></B> </P>
<P align="left">
<font face="Times New Roman" size="3">Для языка системы MATLAB различие между командами (выполняемыми при вводе с клавиатуры) и программными операторами (выполняемыми из программы) является условным. И команды, и программные операторы могут выполняться как из программы, так и в режиме прямых вычислений. Под командами далее в основном понимаются средства, управляющие периферийным оборудованием, под операторами — средства, выполняющие операции с операндами (данными).</font>
</P>
<P align="left">
<I><font face="Times New Roman" size="3">Функция </font> </I><font face="Times New Roman" size="3">преобразует одни данные в другие. Для многих функций характерен возврат значений в ответ на обращение к ним с указанием списка входных параметров — аргументов. Например, говорят, что функция <I>sin(x) </I>в ответ на обращение к ней возвращает значение синуса аргумента <I>х. </I>Поэтому функцию можно использовать в арифметических выражениях, например <I>2*sin(x+1). </I>Для операторов (и команд), не возвращающих значения, такое применение обычно абсурдно. В данной книге все функции, возвращающие единственное значение (или один массив), записываются малыми (строчными) буквами в виде</font>
</P>
<P align="left"><font size="3" face="Courier New">f_nаmе(Список_параметров).</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Тем самым мы исключаем искусственное выделение имен функций большими (заглавными) буквами, принятое в справочной системе MATLAB. Напоминаем, что как в командной строке, так и в текстах m-файлов функции записываются только малыми буквами. Для функций, возвращающих ряд значений или массивов (например X, Y, Z,...), запись имеет следующий вид:
[X. Y, Z. ...]=f_name(Cписок_параметров)</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Важное значение имеет <I>двойственность </I>операторов и функций. Многие операторы имеют свои аналоги в виде функций. Так, например, оператор &laquo;+&raquo; имеет аналог в виде функции sum. Команды, записанные в виде</font>
</P>
<P align="left">
<font size="3" face="Courier New">Command argument</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">нередко имеют форму записи и в виде функции:</font>
</P>
<P align="left">
<font size="3" face="Courier New">Command(' argument')</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Примеры:</font>
</P>
<P align="left">
<font size="3" face="Courier New">&raquo; help sin SIN Sine.<BR>
</font>
</P>
<P align="left">
<font size="3" face="Courier New">SIN(X) is the sine of the elements of X.&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> Overloaded methods</font>
</P>
<P align="left">
<font size="3" face="Courier New">help sym/sin.m</font>
</P>
<P align="left">
<font size="3" face="Courier New">&raquo; help('sin') SIN Sine.</font>
</P>
<P align="left">
<font size="3" face="Courier New">SIN(X) is the sine of the elements of X.</font>
</P>
<P align="left">
<font size="3" face="Courier New">&nbsp;Overloaded methods</font>
</P>
<P align="left">
<font size="3" face="Courier New">help sym/sin.m</font>
</P>
<P align="left">
<font size="3" face="Courier New">&raquo; type('sin')</font>
</P>
<P align="left">
<font size="3" face="Courier New">sin is a built-in function.</font>
</P>
<P align="left">
<font size="3" face="Courier New">&raquo; type sin</font>
</P>
<P align="left">
<font size="3" face="Courier New">sin is a built-in function.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Указанная двойственность лежит в основе выбора между процедурным и функциональным типами программирования, каждый из которых имеет своих поклонников и противников и может (в той или иной мере) подходить для решения различных классов задач. При этом переход от одного типа программирования к другому возможен в пределах одной программы и происходит настолько естественно, что большинство пользователей даже не задумывается над тем, каким же типом (или стилем) программирования они преимущественно пользуются.</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="7"></a>Некоторые 
  ограничения</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Поскольку язык программирования системы MATLAB ориентирован на структурное программирование, в нем нет номеров строк (присущих до недавнего времени Бейсику) и программных операторов безусловного перехода GO TO. Имеются лишь управляющие структуры следующих типов: условных выражений if... el se...elseif...end, циклы for...end и while...end. Их форма похожа на ту, которая используется в языке Pascal (т. е. область действия управляющих структур начинается их заголовком, но без слова begin, а заканчивается словом end). С позиций теории структурного программирования этих средств достаточно для решения любых задач. В MATLAB имеются также операторы-переключатели типа
case.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Однако в MATLAB исключены те средства, возможности которых можно реализовать уже имеющимися средствами. Зато резко увеличен набор средств программирования для решения математических задач, прежде всего сводящихся к матричным вычислениям и реализации современных численных методов.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Программирование простых задач в среде MATLAB очень напоминает программирование на Бейсике. Во многих случаях программы на Бейсике можно почти дословно перевести на язык системы, учтя небольшие отличия в синтаксисе этих языков. Это нельзя трактовать как отсутствие у языка MATLAB индивидуальных черт. Любители Си, Паскаля или Фортрана также заметят сходство этих языков с языком программирования MATLAB. Так что правильнее считать, что этот язык имеет вполне самостоятельное значение. Он вобрал в себя лучшие средства универсальных языков программирования.</font>
</P>
<P align="left"> <B><font face="Times New Roman" size="4"><a name="8"></a>М-файлы 
  сценариев и функций</font></B> </P>
<P align="left"> <font face="Times New Roman" size="4"><a name="9"></a>Структура 
  и свойства файлов сценариев</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Итак, мы установили, что работа в командном режиме (сессия) не является программированием. Внешним атрибутом последнего в MATLAB служит задание последовательности действий по программе, записанной в виде m-файла. В уроке 5 было показано, что для создания m-файлов может использоваться как встроенный редактор, так и любой текстовый редактор, поддерживающий формат ASCII. Подготовленный и записанный на диск m-файл становится частью системы, и его</font>
<font face="Times New Roman" size="3">можно вызывать как из командной строки, так и из другого m-файла. Есть два типа m-файлов: файлы-сценарии и файлы-функции. Важно, что в процессе своего создания они проходят синтаксический контроль с помощью встроенного в систему MATLAB редактора/отладчика m-файлов.</font>
</P>
<P align="left">
<I><font face="Times New Roman" size="3">Файл-сценарий, </font> </I><font face="Times New Roman" size="3">именуемый также Script-файлом, является просто записью серии команд без входных и выходных параметров. Он имеет следующую структуру:</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">&laquo;Основной комментарий %Дополнительный комментарий Тело файла с любыми выражениями</font>
<font face="Times New Roman" size="3">Важны следующие свойства файлов-сценариев:&nbsp;</font>
</P>
<ul>
  <li>
    <p align="left"><font face="Times New Roman" size="3">&nbsp;они не имеют входных и выходных аргументов;&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> работают с данными из рабочей области;&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> в процессе выполнения не компилируются;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">представляют собой зафиксированную в виде файла последовательность операций, полностью аналогичную той, что используется в сессии.</font></li>
</ul>
<P align="left">
<font face="Times New Roman" size="3">Основным комментарием является первая строка текстовых комментариев, а дополнительным — последующие строки. Основной комментарий выводится при выполнении команд lookfor и help имя_каталога. Полный комментарий выводится при выполнении команды help Имя_файла. Рассмотрим следующий файл-сценарий:</font>
</P>
<P align="left">
<font size="3" face="Courier New">%Plot with color red</font>
</P>
<P align="left">
<font size="3" face="Courier New">%Строит график синусоиды линией красного цвета</font>
</P>
<P align="left">
<I><font face="Courier New"><font size="3">%с </font></font> </I><font size="3" face="Courier New">выведенной масштабной сеткой в интервале
[xmin.xmax]</font>
</P>
<P align="left"><font size="3" face="Courier New">x=xmin:0.1:xmax;</font>
</P>
<P align="left">
<font size="3" face="Courier New">plot(x.sin(x).'r')</font>
</P>
<P align="left">
<font size="3" face="Courier New">grid on</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Первые три строки здесь — это комментарий, остальные — тело файла. Обратите внимание на возможность задания комментария на русском языке. Знак <I>% </I>в комментариях должен начинаться с первой позиции строки. В противном случае команда help name не будет воспринимать комментарий (иногда это может понадобиться) и возвратит сообщение вида No help comments found
in-name.m.</font>
</P>
<P align="left"> <font face="Times New Roman" size="3">Обратите внимание на то, 
  что такой файл нельзя запустить без предварительной подготовки, сводящейся к 
  заданию значений переменным xmin и хтах, использованным в теле файла. Это следствие 
  первого свойства файлов-сценариев — они работают с данными из рабочей области. 
  Переменные, используемые в файлах-сценариях, являются глобальными, т. е. они 
  действуют одинаково в командах сессии и внутри программного блока, которым является 
  файл-сценарий. Поэтому заданные в сессии значения переменных используются и 
  в теле файла. Имена файлов-сценариев нельзя использовать в качестве параметров 
  функций, поскольку</font> <font face="Times New Roman" size="3">файлы-сценарии 
  не возвращают значений. Можно сказать, что файл-сценарий — это простейшая программа 
  на языке программирования MATLAB [</font><font face="Times New Roman" size="3"><i>Файлы-сценарии 
  нельзя компилировать. Перед компилированием их нужно преобразовать в файлы-функции 
  — Примеч. ред.</i>].</font> </P>
<P align="left"><img src="20.2.jpg" tppabs="http://orloff.am.tpu.ru/matlab/Append/Info/20.2.jpg" width="421" height="496"></P>
<P align="left">
<B><i><font face="Times New Roman" size="3">Рис.20.2. </font></i> </B><font face="Times New Roman" size="3"><i>Пример работы с файлом
pcr</i></font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="10"></a>Статус 
  переменных в функциях</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Переменные, указанные в списке параметров функции, являются <I>локальными </I>и служат для переноса значений, которые подставляются на их место при вызовах функций.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Эта особенность переменных-параметров хорошо видна при разборе примера, показанного на рис. 20.3. Здесь (признаемся, что неточно) задана некоторая функция двух переменных fun(x, <I>у).</I></font>
</P>
<P align="left"><font face="Times New Roman" size="3">В этом примере в окне редактора создана функция fun двух переменных х и у, вычисляющая z = <I>х<SUP>2</SUP>+у<SUP>2</SUP>. </I>Поскольку переменные <I>х </I>и <I>у </I>указаны как параметры функции fun(x, <I>у), </I>то они являются локальными. В примере вне тела функции им заданы нулевые значения. Очевидно, что при вычислении значения fun(2, 3) в теле функции задается х=2 и у=3. Поэтому результат — z=13. Однако после выхода из тела функции переменные х и у принимают свои исходные значения, равные нулю. Так что эти переменные меняют свои значения на значения параметров функции только локально — в пределах тела функции.<BR>
  А каков статус переменной z в нашем примере? Она, как и любая переменная, определенная 
  в теле функции, также будет локальной. Изначально ее значение</font> <font face="Times New Roman" size="3">не 
  определено. В теле функции переменная принимает значение z=13. А после возврата 
  из функции, как нетрудно увидеть из рис. 18.2, переменная z, несмотря на ее 
  применение в теле функции, остается неопределенной. На это указывает сообщение, 
  отображаемое после попытки вывода значения переменной z.</font> </P>
<P align="left"><img src="20.3.jpg" tppabs="http://orloff.am.tpu.ru/matlab/Append/Info/20.3.jpg" width="320" height="342"> </P>
<P align="left"><B><i><font face="Times New Roman" size="3">Рис. 20.3. </font></i> 
  </B><font face="Times New Roman" size="3"><i>Пример, поясняющий действие локальных 
  и глобальных переменных при задании файла-функции</i></font> </P>
<P align="left">
<font face="Times New Roman" size="3">Возврат из функции производится после обработки всего тела функции, т. е. при достижении конца файла функции. При использовании в теле функции условных операторов, циклов или переключателей иногда возникает необходимость осуществить возврат функции раньше, чем будет достигнут конец файла. Для этого служит команда return. В любом случае, результатом, возвращаемым функцией, являются значения выходных параметров (в нашем случае выходным параметром является переменная z), присвоенные им на момент возврата.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">У нашей функции имеется один недостаток — вывод на индикацию значения z=13 из тела функции, хотя после этого <I>г </I>остается равным 0. Чтобы убрать побочный эффект вывода значения z, достаточно установить знак ; после математического выражения, определяющего z. Таким образом, окончательно наша функция должна записываться следующим образом:</font>
</P>
<P align="left">
<font size="3" face="Courier New">function z=fun(x,y)&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New">z=x^2+y^2;</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Этот пример наглядно показывает, что пропуск любого слова или даже простого оператора (вроде знака :) может привести к не сразу понятным побочным эффектам и даже неверной работе функции. Программирование требует особой точности и педантичности, именно поэтому далеко не все могут быть хорошими программистами.</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="11"></a>Структура 
  М-файла-функции</font> </P>
<P align="left">
<font face="Times New Roman" size="3"><I>М-файл-функция </I>является типичным объектом языка программирования системы MATLAB. Одновременно он является полноценным модулем с точки зрения структурного программирования, поскольку содержит входные и выходные параметры и использует аппарат локальных переменных. Структура такого модуля с одним выходным параметром выглядит следующим образом:</font>
</P>
<P align="left">
<font size="3" face="Courier New">function var=f_name(Cnncoк_napaмeтpов)&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New">%Основной комментарий</font>
</P>
<P align="left">
<font size="3" face="Courier New">%Дополнительный комментарий&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> Тело файла с любыми выражениями&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New">vаг=выражение</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">М-файл-функция имеет следующие свойства:</font>
</P>
<ul>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> он начинается с объявления function, после которого указывается имя переменной van — выходного параметра, имя самой функции и список ее входных параметров;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">функция возвращает свое значение и может использоваться в виде name (Список_параметров) в математических выражениях;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">все переменные, имеющиеся в теле файла-функции, являются <I>локальными, </I>т. е. действуют только в пределах тела функции;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">файл-функция является самостоятельным программным модулем, который общается с другими модулями через свои входные и выходные параметры;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">правила вывода комментариев те же, что у файлов-сценариев;&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> файл-функция служит средством расширения системы MATLAB;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">при обнаружении файла-функции он компилируется и затем исполняется, а созданные машинные коды хранятся в рабочей области системы MATLAB.</font></li>
</ul>
<P align="left">
<font face="Times New Roman" size="3">Последняя конструкция
vаг=выражение вводится, если требуется, чтобы функция возвращала результат вычислений.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Приведенная форма файла-функции характерна для функции с одним выходным параметром. Если выходных параметров больше, то они указываются в квадратных скобках после слова function. При этом структура модуля имеет следующий вид:</font>
</P>
<P align="left">
<font size="3" face="Courier New">function [varl,var2....]=f_name(Список_параметров)</font>
</P>
<P align="left"><font size="3" face="Courier New">%Основной комментарий</font>
</P>
<P align="left"><font size="3" face="Courier New">%Дополнительный комментарий</font>
</P>
<P align="left">
<font size="3" face="Courier New">Тело файла с любыми выражениями</font>
</P>
<P align="left">
<font size="3" face="Courier New">vаг1=выражение</font>
</P>
<P align="left">
<font size="3" face="Courier New">vаг2=выражение</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Такая функция во многом напоминает процедуру. Ее нельзя слепо использовать непосредственно в математических выражениях, поскольку она возвращает не единственный результат, а множество результатов — по числу выходных параметров. Если функция используется как имеющая единственный выходной параметр, но имеет ряд выходных параметров, то для возврата значения будет использоваться первый из них. Это зачастую ведет к ошибкам в математических</font>
<font face="Times New Roman" size="3">вычислениях. Поэтому, как отмечалось, данная функция используется как отдельный элемент программ вида:</font>
</P>
<P align="left">
<font size="3" face="Courier New">[varl,va2,... ]=f_nаmе(Список_параметров)</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">После его применения переменные выхода varl, var2,... становятся определенными и их можно использовать в последующих математических выражениях и иных сегментах программы. Если функция используется в виде
nаmе(Список_параметров), то возвращается значение только первого выходного параметра — переменной varl.</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="12"></a>Статус 
  переменных и команда global</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Итак, из сказанного ясно, что переменные в файлах-сценариях являются <I>глобальными, </I>а в файлах-функциях — <I>локальными. </I>Нередко применение глобальных переменных в программных модулях может приводить к побочным эффектам. Применение локальных переменных устраняет эту возможность и отвечает требованиям структурного программирования.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Однако передача данных из модуля в модуль в этом случае происходит только через входные и выходные параметры, что требует тщательного планирования такой передачи. В жизни мы далеко не всегда едим черную икру (локальные переменные) и часто хотим отведать черного хлебушка (глобальные переменные). Так и при создании файлов-функций порой желательно применение глобальных переменных. Ответственность за это должен брать на себя программист, создающий программные модули.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Команда global varl var2... позволяет объявить переменные модуля-функции глобальными. Таким образом, внутри функции могут использоваться и такие переменные, если это нужно по условиям решения вашей задачи
[<i>Чтобы несколько программных модулей могли совместно использовать глобальную переменную, i идентификатор должен быть объявлен как global
во всех модулях.</i>].</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="13"></a>Использование 
  подфункций</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Начиная с версии 5.0 в функции системы MATLAB можно включать <I>подфункции. </I>Они объявляются и записываются в теле основных функций и имеют идентичную им конструкцию. Не следует путать эти функции с внутренними функциями, встроенными в ядро системы MATLAB. Ниже представлен пример функции с подфункцией:</font>
</P>
<P align="left">
<font size="3" face="Courier New">function [mean.stdev] = statv(x)</font>
</P>
<P align="left">
<font size="3" face="Courier New">USTATV Interesting statistics.</font>
</P>
<P align="left">
<font size="3" face="Courier New">%Пример функции с встроенной подфункций</font>
</P>
<P align="left">
<font size="3" face="Courier New">n = length(x);</font>
</P>
<P align="left">
<font size="3" face="Courier New">mean = avg(x.n);</font>
</P>
<P align="left">
<font size="3" face="Courier New">stdev = sqrt(sum((x-avg(x.n)).<sup>^</sup>2)/n);</font>
</P>
<P align="left">
<font size="3" face="Courier New">%--------------------------------------</font>
</P>
<P align="left">
<font size="3" face="Courier New">function m = avg(x.n) &pound;Mean subfunction m = sum(x)/n;</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">В этом примере среднее значение элементов вектора х вычисляется с помощью подфункции avg(x.n), тело которой записано в теле основной функции statv. Пример использования функции statv представлен ниже:</font>
</P>
<P align="left">
<font size="3" face="Courier New">&raquo; V=[l 2345]</font>
</P>
<P align="left">
<font size="3" face="Courier New">V=</font>
</P>
<P align="left">
<font size="3" face="Courier New">12345&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> &raquo; [a,m]=statv(V)</font>
</P>
<P align="left">
<font size="3" face="Courier New">&nbsp;а =</font>
</P>
<P align="left">
<font size="3" face="Courier New">3&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> m =<BR>
</font>
</P>
<P align="left">
<font size="3" face="Courier New">1.4142 &raquo; statv(V)&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> ans =</font>
</P>
<P align="left">
<font size="3" face="Courier New">3</font>
</P>
<P align="left">
<font size="3" face="Courier New">&raquo; help statv</font>
</P>
<P align="left">
<font size="3" face="Courier New">STATV Interesting statistics.&nbsp;</font>
</P>
<P align="left">
<font face="Times New Roman" size="3"> Пример функции с встроенной подфункций</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Подфункции определены и действуют локально, т. е. только в пределах т-файла, определяющего основную функцию. Команда help пате выводит комментарий, относящийся только к основной функции, тогда как команда type name выводит весь листинг m-файла. Так что заданные в некотором m-файле подфункции нельзя использовать ни в командном режиме работы, ни в других т-файлах. При обращении к функции интерпретатор системы MATLAB прежде всего просматривает m-файл на предмет выявления подфункций. Если они обнаружены, то задаются как локальные функции. Благодаря локальному действию подфункций их имена могут совпадать с именами основных функций системы. Если в функции и подфункциях должны использоваться общие переменные, их надо объявить глобальными как в функции, так и в ее подфункциях.</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="14"></a>Частные 
  каталоги</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Для записи m-файлов используются каталоги, называемые <I>родительскими каталогами. </I>Они содержат группы файлов определенного функционального назначения, например по статистическим расчетам, матричным операциям, вычислению определенных классов функций и т. д.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Однако начиная с версии MATLAB 5.0 появилась возможность в родительских каталогах создавать <I>частные каталоги </I>с именем PRIVATE. Расположенные в них m-файлы доступны только файлам родительского каталога. Файлы частных каталогов просматриваются интерпретатором системы MATLAB в первую очередь. Применение частных каталогов позволяет изменять исходные файлы, сохраняя оригиналы в родительском каталоге в неизменном виде.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Если вы решили отказаться от применения измененного файла, достаточно стереть его в частном каталоге. Такая возможность связана с тем, что интерпретатор при поиске m-файла прежде всего просматривает частный каталог и интерпретирует найденный в нем файл. И только если файл не найден, ищется файл в родительском каталоге.</font>
</P>
<P align="left"> <B><font face="Times New Roman" size="4"><a name="15"></a>Обработка 
  ошибок</font></B> </P>
<P align="left"> <font face="Times New Roman" size="4"><a name="16"></a>Вывод 
  сообщений об ошибках</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Часто в ходе вычислений возникают ошибки. Например, мы уже сталкивались с проблемой вычисления функции <I>sin(x)/x — </I>при <I>х </I>= 0 имеет место ошибка вида &laquo;деление на ноль&raquo;. При появлении ошибки вычисления могут завершиться досрочно с выводом сообщения об ошибке. Следует, однако, отметить, что не все ошибки вызывают остановку вычислений. Некоторые сопровождаются только выдачей предупреждающей надписи.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Такие ситуации должны учитываться программистом, отмечаться как ошибочные и по возможности устраняться. Для вывода сообщения об ошибке служит команда
error('Сообщение об ошибке'), при выполнении которой вычисления прерываются и выдается сообщение об ошибке, заданное в апострофах. Ниже дан пример вычисления функции <I>sd(x)=sin(x)/x, </I>в котором задано сообщение об ошибке на русском языке:</font>
</P>
<P align="left">
<font size="3" face="Courier New">function f=sd(x)</font>
</P>
<P align="left">
<font size="3" face="Courier New">if x==0 error('Ошибка - деление на 0'). end</font>
</P>
<P align="left">
<font size="3" face="Courier New">f=sin(x)/x</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Для выявления ситуации об ошибке использован оператор условного перехода if, который будет описан детально несколько позднее. Результат выполнения данной функции приводится ниже:</font>
</P>
<P align="left">
<font size="3" face="Courier New">&raquo; sd(l)&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> f =</font>
</P>
<P align="left">
<font size="3" face="Courier New">0.8415&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> ans =</font>
</P>
<P align="left">
<font size="3" face="Courier New">0.8415&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> &raquo; sd(0)</font>
</P>
<P align="left">
<font size="3" face="Courier New">??? Error using ==&gt; sd Ошибка - деление на
0</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Если остановка программы при появлении ошибки нежелательна, то может использоваться команда вывода предупреждающего сообщения warning('Предупреждающее сообщение')</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Эта команда выводит стоящее в апострофах сообщение, но не препятствует дальнейшей работе программы. Признаком того, что является ошибкой, а что — предупреждением, являются символы ??? и слово Warning в соответствующих сообщениях.</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="17"></a>Функция 
  lasterr и обработка ошибок</font><font face="Times New Roman" size="3"><BR>
  </font> </P>
<P align="left">
<font face="Times New Roman" size="3">Опытные программисты должны предусматривать ситуации с появлением ошибок. К примеру, при <I>х = </I>0 выражение <I>sin(x)/x = </I>0/0 = 1 и правильным решением было бы вместо его вычисления использовать значение 1.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">В данном простом примере приводится функция sdO, исключающая вычисление <I>sin(x)/x </I>при <I>х = </I>0:</font>
</P>
<P align="left">
<font size="3" face="Courier New">function f=sdO(x)&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> if x==0 f-1:&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> else f=sin(x)/x;&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> end&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> return</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">При этом вычисления пройдут корректно при любом <I>х:</I></font>
</P>
<P align="left">
<font face="Courier New"><font size="3">&raquo; sd0(l)</font></font>
</P>
<P align="left">
<font size="3" face="Courier New">ans=<BR>
</font>
</P>
<P align="left">
<font size="3" face="Courier New">0.8415&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> &raquo;sd0(0)&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> ans =&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New">1</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Для вывода сообщения о последней произошедшей ошибке служит функция lasterr (см. пример ниже):</font>
</P>
<P align="left">
<font size="3" face="Courier New">&raquo; ааа</font>
</P>
<P align="left">
<font size="3" face="Courier New">??? Undefined function or variable 'aaa'.&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New">» 2+3&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> ans =</font>
</P>
<P align="left">
<font size="3" face="Courier New">5</font>
</P>
<P align="left">
<font size="3" face="Courier New">&raquo; 1/0</font>
</P>
<P align="left">
<font size="3" face="Courier New">Warning: Divide by zero,&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> ans =</font>
</P>
<P align="left">
<font size="3" face="Courier New">Inf</font>
</P>
<P align="left">
<font size="3" face="Courier New">&raquo; lasterr&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> ans = Undefined function or variable 'aaa'.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Как нетрудно заметить, функция lasterr возвращает текстовое сообщение, следующее за знаками ??? сообщения об ошибке.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">В общем случае программы могут содержать <I>обработчики ошибок, </I>направляющие ход вычислений в нужное русло, даже если появляется ошибка. Но для этого требуются средства индикации и обработки ошибок. Основными из них являются функции eval и
l asterr. О функции lasterr уже говорилось, а функция eval (' try', 'catch') в отличие от ранее рассмотренной формы (урок 18) имеет два входных аргумента. Один из них — это строчное выражение, которое преобразуется в исполняемую форму и выполняется при отсутствии ошибки. Если же происходит ошибка, то строка ' catch' вызывает обращение к функции обработки ошибки.</font>
</P>
<P align="left"> <B><font face="Times New Roman" size="4"><a name="18"></a>Функции 
  с переменным числом аргументов</font></B> </P>
<P align="left"> <font face="Times New Roman" size="4"><a name="19"></a>Функции 
  подсчета числа аргументов</font> </P>
<P align="left">
<font face="Times New Roman" size="3">При создании функций со специальными свойствами весьма полезны две приведенные ниже функции:</font>
</P>
<ul>
  <li>
    <p align="left"><font face="Times New Roman" size="3">nargin — возвращает число входных параметров данной функции;&nbsp;</font></li>
  <li>
    <p align="left"><font face="Times New Roman" size="3"> nargout — возвращает число выходных параметров данной функции.</font></li>
</ul>
<P align="left">
<font face="Times New Roman" size="3">Пусть, к примеру, мы хотим создать функцию, вычисляющую сумму квадратов пяти аргументов xl, х2, хЗ, х4 и х5.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Обычный путь состоит в следующем — создаем функцию с именем sum2_5:</font>
</P>
<P align="left"><font size="3" face="Courier New">function f=sum2_5(x1,x2,x3,x4,x5)
;</font>
</P>
<P align="left"><font size="3" face="Courier New">f=x1^2+x2^2+x3^2+x4*2+x5^*2;</font>
</P>
<P align="left">
<font size="3" face="Courier New">Теперь проверим ее в работе:</font>
</P>
<P align="left">
<font size="3" face="Courier New">&raquo; sum2_5(l,2.3.4.5)&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> ans =&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> 55</font>
</P>
<P align="left">
<font size="3" face="Courier New">&raquo; sum2_5(l,2)
</font>
</P>
<P align="left">
<font size="3" face="Courier New">??? Input argument 'хЗ' is undefined.&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> Error in ==&gt;  C:\MATI_AB\bin\sum2_5.m&nbsp;</font>
</P>
<P align="left">
<font size="3" face="Courier New"> On line 2   ==&gt; f=xl&quot;2+x2&quot;2+x3&quot;2+x4&quot;2+x5&quot;2;</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Итак, при наличии всех пяти аргументах функция работает корректно. Но если аргументов менее пяти, она выдает сообщение об ошибке. С помощью функции nargin можно создать функцию sum2_5m, которая работает корректно при любом числе заданных входных аргументов в пределах от 1 до 5:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">function f=sum2m_5(xl . x2 , хЗ . x4 , x5) ;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">n=nargin;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">if n==1 f=xl^2; end</font>
</P>
<P align="left">
<font face="Courier New" size="3">if n==2 f=xl^2+x2^2;end</font>
</P>
<P align="left">
<font face="Courier New" size="3">if n==3 f=xl^2+x2^2+x3^2; end</font>
</P>
<P align="left">
<font face="Courier New" size="3">if n==4 f=xl^2+x2<sup>^</sup>2+x3^2+x4<sup>^</sup>2: end
</font>
</P>
<P align="left">
<font face="Courier New" size="3">if n==5 f=xl^2+x2^2+x3^2+x</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">В данной функции используется условный оператор i f...end, который будет детально описан далее. Но и без этого ясно, что благодаря применению функции nargin и условного оператора вычисления всякий раз идут по формуле с числом слагаемых, равным числу входных аргументов — от одного до пяти. Это видно из приведенных ниже примеров:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; sum2_5m(l)&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> 1</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; sum2_5m(l,2)&nbsp;</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =</font>
</P>
<P align="left">
<font size="3" face="Courier New">5</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; sum2_5m( 1.2.3)
</font>
</P>
<P align="left">
<font face="Courier New" size="3">ans =&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">14
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; sum2_5m(l,2.3,4)&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">30
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; sum2_5m(1.2.3,4,5)&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans=
</font>
</P>
<P align="left">
<font face="Courier New" size="3">55
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; sum2_5m(1.2.3.4,5,6)&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ??? Error using ==&gt; sum2_5m&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Too many input arguments.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Итак, при изменении числа входных параметров от 1 до 5 вычисления проходят корректно. При большем числе параметров выводится сообщение об ошибке. Этс уже действует встроенная в интерпретатор MATLAB система диагностики ошибок
</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="20"></a>Переменные 
  varargin и varargout</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Для упрощения записи аргументов функций их можно представить списком, который определяет специальная переменная varargin, являющаяся массивом ячеек. Она должна записываться строчными буквами и может включать в себя как аргументы, так и опции функций. Например, в приведенных ниже примерах:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">function myplotCx.varargin)
</font>
</P>
<P align="left">
<font face="Courier New" size="3">plot(x,varargin{:})    function [s,varargout] =
mysize(x)
</font>
</P>
<P align="left">
<font face="Courier New" size="3">nout - max(nargout.1)-1;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">s = size(x);
</font>
</P>
<P align="left">
<font face="Courier New" size="3">for 1=1:nout, varargout(i) = {s(i)}: end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Эта переменная вбирает в себя все входные параметры и опции начиная со второго аргумента. При обращении к данной функции
</font>
</P>
<P align="left">
<font face="Courier New" size="3">myplot(sin(0:.1:1),'color'.[.5 .7 ,3],'linestyle',':')
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">varargin представляет массив ячеек размера 1x4, включающий а себя значения
</font>
</P>
<P align="left">
<font face="Courier New" size="3">'color', [.5 .7 .3], 'linestyle' u ':'.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Аналогично varagin переменная varargout объединяет любое число <I>выходных </I>параметров в массив ячеек. Эта переменная, кстати, как и varargin, должна быть последней в списке аргументов. Обычно эта переменная не создается при вызове функций. Приведенный ниже пример поясняет ее создание с помощью цикла:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">function [s,varargout] = rnysize(x)&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> nout = max(nargout,l)-l:&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> s = size(x):&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> for i-l:nout.&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">varargout(i)= (s(i)}: end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Более подробно циклы будут рассмотрены в дальнейшем описании. В данном случае цикл использован для объединения всех параметров начиная со второго в значение переменной
varargout.
</font>
</P>
<P align="left"> <B> <font face="Times New Roman" size="4"><a name="21"></a>Комментарии</font></B> 
</P>
<P align="left">
<font face="Times New Roman" size="3">Как отмечалось, команда help name, где name — имя m-файла, обеспечивает чтение первой строки с текстовым комментарием и тех строк с комментариями, которые следуют непосредственно за первой строкой. Комментарий, расположенный за пределами этой области, не выводится. Это позволяет создавать невыводимый программный комментарий, например: Z=X+Y ^Массив Z является суммой массивов X и Y</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Пустая строка прерывает вывод комментария при исполнении команды help name. Команда type name выводит текст программы со всеми комментариями, в том числе и следующими после пустых строк.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Команда help catalog, где catalog — имя каталога с m-файлами, позволяет вывести комментарий, общий для всего каталога. Такой комментарий содержится в файле</font>
<font face="Times New Roman" size="3">contents.m, который пользователь может создать самостоятельно с помощью редактора m-файлов. Если такого файла нет, то будет выведен список первых строк комментариев для всех m-файлов каталога.</font>
</P>
<P align="left"> <B><font face="Times New Roman" size="4"><a name="22"></a>Особенности 
  выполнения m-файлов функций</font></B> </P>
<P align="left">
<font face="Times New Roman" size="3">М-файлы-функции могут использоваться как в командном режиме, так и вызываться из других M-файлов. При этом необходимо указывать все входные и выходные параметры. Исключением является случай, когда выходной параметр единственный — в этом варианте функция возвращает единственный результат и может использоваться в математических выражениях. При использовании глобальных переменных они должны быть объявлены во всех m-файлах, используемых в решении заданной задачи, и во всех входящих в них встроенных подфункциях.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Имена функций должны быть уникальными. Это связано с тем, что при обнаружении каждого нового имени MATLAB проверяет, относится ли это имя к переменной, подфункции в данном m-файле, частной функции в каталогах PRIVATE или функции в одном из каталогов пути доступа. Если последняя встречается, то будет исполнена именно эта функция. В новой версии MATLAB возможно переопределение функции, но это не рекомендуется делать подавляющему большинству пользователей системы.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Если аргумент функции используется только для вычислений и его значения не меняются, то аргумент передается ссылкой, что уменьшает затраты памяти. В других случаях аргумент передается значением. Для каждой функции выделяется своя (рабочая) область памяти, не входящая в область, предоставляемую системе MAT-LAB. Глобальные переменные принадлежат ряду областей памяти. При их изменении меняется содержимое всех этих областей.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">При решении задач с большим объемом данных может ощущаться нехватка оперативной памяти. Признаком этого становится появление сообщения об ошибке &laquo;Out of memory&raquo;.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">В этом случае может быть полезным применение следующих мер:
</font>
</P>
<ul>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> стирание ставших ненужными данных, прежде всего больших массивов;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3">увеличение размеров файла подкачки
Windows;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> уменьшение размера используемых данных;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> снятие ограничений на размеры используемой памяти;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3">увеличение объема физической памяти компьютера.
</font>
  </li>
</ul>
<P align="left">
<font face="Times New Roman" size="3">Чем больше емкость ОЗУ компьютера, на котором используется система MATLAB тем меньше вероятность возникновения указанной ошибки. Опыт показывает, что даже при решении задач умеренной сложности емкость ОЗУ не должна быть менее 16-32 Мбайт.
</font>
</P>
<P align="left"> <B><font face="Times New Roman" size="4"><a name="23"></a>Создание 
  Р-кодов</font></B> </P>
<P align="left">
<font face="Times New Roman" size="3">Когда встречается сценарий или функция в виде m-файла, то всякий раз выполняется трансляция файлов, создающая так называемые Р-коды (псевдокоды). Она связана с синтаксическим контролем сценария или функции, который несколько замедляет вычисления. Временные Р-коды хранятся в памяти только до использования команды clear или завершения сеанса работы. Кроме того, MATLAB позволяет явно создавать и хранить Р-коды сценариев и функций с помощью команды pcode: pcode имена_М-файлов</font>
<font face="Times New Roman" size="3">pcode *.m создает файлы р-кодов для всех m-файлов данной папки, pcode с дополнительным параметром - inplace — хранит эти файлы в тех же папках, что и исходные
m-файлы.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Особенно полезно применение этой команды в том случае, когда используется сложная дескрипторная графика и средства создания GUI. В этом случае выигрыш по скорости выполнения вычислений может быть заметным. Переход к Р-кодам полезен, если пользователь желает скрыть созданный им m-файл и реализованные в нем идеи и алгоритмы. Файл с Р-кодами имеет расширение .р. Размер файла с Р-кодами обычно больше, чем размер
m-файла.Рассмотрим следующий пример — создадим файл-сценарий pp.m следующего содержания:</font>
</P>
<P align="left">
<font face="Courier New" size="3">told=cputime;&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> х=-15:.0001:15;&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">plot(x.sin(x))&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">t=cputime-told
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Эта программа строит график функции <I>sin(x) </I>по большому числу точек. Кроме того, она вычисляет время выполнения данного сценария в секундах. При первом пуске получим:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; рр
</font>
</P>
<P align="left">
<font face="Courier New" size="3">t=
</font>
</P>
<P align="left">
<font face="Courier New" size="3">0.4400
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Теперь выполним создание Р-кодов и вновь запустим программу:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; pcode рр&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo; рр
</font>
</P>
<P align="left">
<font face="Courier New" size="3">t=
</font>
</P>
<P align="left">
<font face="Courier New" size="3">0.3900&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo; рр&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> t =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">0.3300
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Нетрудно заметить, что после преобразования в Р-коды время построения графика несколько уменьшилось. Но гораздо важнее то, что теперь вы можете стереть файл pp.m (но оставить рр.р!) и снова запустить программу. Ваши слишком любопытные коллеги едва ли разберутся с тем, что записано в машинных кодах файла рр.р, хотя с помощью специальных программ (декомпиляторов) такая возможность реализуется.
</font>
</P>
<P align="left"> <B> <font face="Times New Roman" size="4"><a name="24"></a>Управляющие 
  структуры</font></B> </P>
<P align="left">
<font face="Times New Roman" size="3">Помимо программ с <I>линейной структурой, </I>инструкции которых исполняются строго по порядку, существует множество программ, структура которых <I>нелинейна. </I>При этом ветви программ могут выполняться в зависимости от определенных условий, иногда с конечным числом повторений — циклов, иногда в виде циклов, завершаемых при выполнении заданного условия. Практически любая серьезная программа имеет нелинейную структуру. Для создания таких программ необходимы специальные управляющие структуры. Они имеются в любом языке программирования, и в частности в
MATLAB.
</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="25"></a>Диалоговый 
  ввод</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Приведем простой пример диалоговой программы, которую легко поймут приверженцы доброго старого Бейсика:
</font>
</P>
<P align="left">
<I>
<font face="Courier New" size="3">%
</font>
 </I>
<font face="Courier New" size="3">Вычисление длины окружности с диалоговым вводом радиуса
</font>
</P>
<P align="left">
<font face="Courier New" size="3">r=0;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">while r&gt;=0,
</font>
</P>
<P align="left">
<font face="Courier New" size="3">r=input('Введите радиус окружностиr=');
</font>
</P>
<P align="left">
<font face="Courier New" size="3">if r&gt;=0 disp(' Длина окружности
l='); disp(2*pi*r), end&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Эта программа служит для многократного вычисления длины окружности по вводимому пользователем значению радиуса г. Обратите внимание на то, что здесь мы впервые показываем пример организации простейшего диалога. Он реализован с помощью команды input: MnputCВведите радиус окружности
r='):
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">При выполнении этой команды вначале выводится запрос в виде строки, затем происходит остановка работы программы и ожидается ввод значения радиуса г (в общем случае числа). Ввод, как обычно, подтверждается нажатием клавиши Enter, после чего введенное число присваивается переменной г. Следующая строка
</font>
</P>
<P align="left">
<font face="Courier New" size="3">if r&gt;=0 disp(' Длина окружности
l = '); disp(2*pi*r), end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">с помощью команды disp при
r&gt;=0 выводит надпись &laquo;Длина окружности 1=&raquo; и вычисленное значение длины окружности. Она представляет собой одну из наиболее простых управляющих структур типа if...end. В данном случае она нужна для остановки вычислений, если вводится отрицательное значение г (прием, который любят начинающие программисты).
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Приведенные строки включены в управляющую структуру while...end. Это необходимо для циклического повторения вычислений с вводом значений
r. Пока r&gt;=0. цикл повторяется. Но стоит задать
r&lt;0, вычисление длины окружности перестает выполняться, а цикл завершается.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Если данная программа записана в виде m-файла
circ.m, то работа с ней будет&nbsp; выглядеть следующим образом:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; circ
</font>
</P>
<P align="left">
<font face="Courier New" size="3">Введите радиус окружности
R=1&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Длина окружности l=
</font>
</P>
<P align="left">
<font face="Courier New" size="3">6.2832
</font>
</P>
<P align="left">
<font face="Courier New" size="3">Введите радиус окружности R=2&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Длина окружности l=
</font>
</P>
<P align="left">
<font face="Courier New" size="3">12.5664
</font>
</P>
<P align="left">
<font face="Courier New" size="3">Введите радиус окружности
R=-1&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo;
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Итак, на примере даже простой программы мы видим пользу применения управляющих структур типа if...end и whi1e...end, а также функций диалогового ввода input('String') и вывода disp. Обратите внимание на завершение работы программы при вводе любого отрицательного числа для радиуса окружности.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Функция Input может использоваться и для ввода произвольных строковых выражений. При этом она задается в следующем виде:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">input('Комментарий'. V)
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">При выполнении этой функции она останавливает вычисления и ожидает ввода строкового комментария. После ввода возвращается набранная строка. Это иллюстрирует следующий пример:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; S=input('Введите выражение ','s') Введите выражение (Вводим) 2*sin(l)&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> S =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">2*sin(l)&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo; eval(S)&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">1.6829
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Обратите внимание на то, что функция eval позволяет вычислить выражение, заданное (полученное от функции input) в символьном виде. Вообще говоря, возможность ввода любого символьного выражения в сочетании с присущими языку программирования MATLAB управляющими структурами открывает путь к созданию диалоговых программ любой сложности
[<i>Нужно проявлять большую осторожность при применении eval и
input, так как программы с их с использованием не всегда возможно компилировать. Впрочем, р-коды таких программ можно использовать с сервером
run-time. — Примеч. ред.</i>].</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="26"></a>Условный 
  оператор</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Условный оператор if в общем виде записывается следующим образом:
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">i</font><font face="Courier New" size="3">f Условие&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Инструкции_1
</font>
</P>
<P align="left">
<font face="Courier New" size="3">elself Условие&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Инструкции_2&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> else&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">Инструкции_3&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Эта конструкция допускает несколько частных вариантов. В простейшем, типа! f...end: if   Условие   Инструкции end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Пока Условие возвращает логическое значение 1 (то есть &laquo;истина&raquo;), выполняются Инструкции, составляющие тело структуры if...end. При этом оператор end указывает на конец перечня инструкций. Инструкции в списке разделяются оператором , (запятая) или ; (точка с запятой). Если Условие не выполняется (дает логическое значение 0, &laquo;ложь&raquo;), то Инструкции также не выполняются.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Еще одна конструкция
</font>
</P>
<P align="left">
<font face="Courier New" size="3">if Условие&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Инструкции_1&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> else&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Инструкции_2&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">выполняет Инструкции_1, если выполняется Условие, или Инструкции_2 в противном</font>
<font face="Times New Roman" size="3">случае.</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Условия записываются в виде:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">Выражение_1 Оператор_отношения Выражение_2,
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">причем в качестве Операторов_отношения используются следующие операторы: ==, &lt;, &gt;, &lt;=, &gt;= или ~=. Все эти операторы представляют собой пары символов без пробелов между ними.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Мы уже неоднократно показывали применение этой общеизвестной управляющей структуры в программных модулях. Читателю предлагается опробовать собственные варианты программ с условным оператором.
</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="27"></a>Циклы 
  типа for...end</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Циклы типа for...end обычно используются для организации вычислений с заданным числом повторяющихся циклов. Конструкция такого цикла имеет следующий вид:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">for vаг=Выражение. Инструкция. .... Инструкция end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Выражение чаще всего записывается в виде s:d:e, где s — начальное значение переменной цикла var, d — приращение этой переменной и е — конечное значение управляющей переменной, при достижении которого цикл завершается. Возможна и запись в виде s :е (в этом случае d=l). Список выполняемых в цикле инструкций завершается оператором end.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Следующие примеры поясняют применение цикла для получения квадратов значений переменной цикла:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; for 1=1:5 i^2. end;&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">1&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">4&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">9&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">16&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">25
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; for x=0:.25:1 Х<sup>^</sup>2, end:&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">0&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">0.0625&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">0.2500
</font>
</P>
<P align="left">
<font face="Courier New" size="3">ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">0.5625&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">1
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Оператор continue передает управление в следующую итерацию цикла, пропуская операторы, которые записаны за ним, причем во вложенном цикле он передает управление на следующую итерацию основного цикла. Оператор break может использоваться для досрочного прерывания выполнения цикла. Как только он встречается в программе, цикл прерывается. Возможны вложенные циклы, например:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">for 1=1:3
</font>
</P>
<P align="left">
<font face="Courier New" size="3">for j=l:3
</font>
</P>
<P align="left">
<font face="Courier New" size="3">A(1.j)=i+j;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">end&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">В результате выполнения этого цикла (файл for2.m) формируется матрица А:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; for2&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo; А
</font>
</P>
<P align="left">
<font face="Courier New" size="3">А =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">2 3 4
</font>
</P>
<P align="left">
<font face="Courier New" size="3">3 4 5
</font>
</P>
<P align="left">
<font face="Courier New" size="3">4 5 6&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo;
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Следует отметить, что формирование матриц с помощью оператора : (двоеточие) обычно занимает намного меньше времени, чем с помощью цикла. Однако применение цикла нередко оказывается более наглядным и понятным.</font>
<font face="Times New Roman" size="3">MATLAB допускает использование в качестве переменной цикла массива А размера <I>тхп. </I>При этом цикл выполняется столько раз, сколько столбцов в массиве А, и на каждом шаге переменная var представляет собой вектор, соответствующий текущему столбцу массива А:</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; А=[1 2 3:4 5 6]&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> А =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">1    2    3
</font>
</P>
<P align="left">
<font face="Courier New" size="3">4 5 6&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo; for var=A; var, end&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> var =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">1
</font>
</P>
<P align="left">
<font face="Courier New" size="3">4&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> var =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">2
</font>
</P>
<P align="left">
<font face="Courier New" size="3">5
</font>
</P>
<P align="left">
<font face="Courier New" size="3">var=
</font>
</P>
<P align="left">
<font face="Courier New" size="3">3
</font>
</P>
<P align="left">
<font face="Courier New" size="3">6
</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="28"></a>Циклы 
  типа while...end</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Цикл типа while выполняется до тех пор, пока выполняется Условие:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">while Условие Инструкции end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Пример применения цикла while уже приводился. Досрочное завершение циклов реализуется с помощью операторов break или continue.
</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="29"></a>Конструкция 
  переключателя</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Для осуществления множественного выбора (или ветвления) используется конструкция с переключателем типа switch:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">switch switch_Bыражение&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> case саsе_Выражение&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Список_инструкций
</font>
</P>
<P align="left">
<font face="Courier New" size="3">case {саsе_Выражение1, Саsе_выражение2, саsе_ВыражениеЗ....}&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Список_инструкций
</font>
</P>
<P align="left">
<font face="Courier New" size="3">otherwise. Список_инструкций end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Если выражение после заголовка switch имеет значение одного из выражений са5е_Выражение..., то выполняется блок операторов case, в противном случае — список инструкций после оператора otherwise. При выполнении блока case исполняются те списки инструкций, для которых сазе_Выражение совпадает со switch_Bbipa-жением. Обратите внимание на то, что сазе_Выражение может быть числом, константой, переменной, вектором ячеек или даже строчной переменной. В последнем случае оператор case истинен, если функция strcmp (значение, выражение) возвращает логическое значение &laquo;истине&raquo;.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Поясним применение оператора switch на примере m-файла
swl.m:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">switch van&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> case {1,2,3}
</font>
</P>
<P align="left">
<font face="Courier New" size="3">dispCПервый квартал')&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> case {4,5,6}
</font>
</P>
<P align="left">
<font face="Courier New" size="3">disp('Второй квартал')&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> case {7,8,9}
</font>
</P>
<P align="left">
<font face="Courier New" size="3">d.isp( 'Третий квартал')&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> case {10.11,12}
</font>
</P>
<P align="left">
<font face="Courier New" size="3">dispC Четвертый квартал')&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> otherwise
</font>
</P>
<P align="left">
<font face="Courier New" size="3">disp('Ошибка в задании')&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Эта программа в ответ на значения переменной van — номера месяца — вычисляет, к какому кварталу относится заданный месяц, и выводит соответствующее сообщение:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; var=2;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; swl
</font>
</P>
<P align="left">
<font face="Courier New" size="3">Первый квартал&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo; var=4;swl&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Второй квартал&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo; var=7:swl&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Третий квартал&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo; var=12;swl&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Четвертый квартал
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; var=-l;swl&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Ошибка в задании
</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="30"></a>Конструкция 
  try...catch...end</font> </P>
<P align="left">
<font face="Times New Roman" size="3">В MATLAB 6 введена новая конструкция блока вывода ошибок
try...catch...end:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">try.
</font>
</P>
<P align="left">
<font face="Courier New" size="3">Список инструкций
</font>
</P>
<P align="left">
<font face="Courier New" size="3">Список инструкций catch.
</font>
</P>
<P align="left">
<font face="Courier New" size="3">Список инструкций
</font>
</P>
<P align="left">
<font size="3" face="Courier New">...</font>
</P>
<P align="left">
<font face="Courier New" size="3">Список инструкций&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Эта конструкция выполняет все списки инструкций. Если в каком-то списке до оператора catch появляется ошибка, то выводится сообщение об ошибке, но системная переменная последней ошибки lasterr не меняется. В сообщениях после catch сообщения об ошибке не выводятся.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">В следующем примере задано появление ошибки (переменная ааа не определена), после чего выполняется блок
try...catch...end:</font>
</P>
<P align="left">
<font face="Courier New" size="3">ааа</font>
</P>
<P align="left">
<font face="Courier New" size="3">??? Undefined function or variable 'ааа'.
</font>
</P>
<P align="left">
<font face="Courier New" size="3">try
</font>
</P>
<P align="left">
<font face="Courier New" size="3">2+3:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">3+4:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">2/0: catch
</font>
</P>
<P align="left">
<font face="Courier New" size="3">4+5: end:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">Warning: Divide by zero.&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo;lasterr ans = Undefined function or variable
'aaa'.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Обратите внимание, что в конце блока команда lasterr выводит ее начальное значение. А в другом примере ошибка задана в блоке try...catch...end уже после оператора
catch:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; try
</font>
</P>
<P align="left">
<font face="Courier New" size="3">2+3:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">3+4;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">4+5: catch
</font>
</P>
<P align="left">
<font face="Courier New" size="3">5/0:&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">end:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; lasterr
</font>
</P>
<P align="left">
<font face="Courier New" size="3">ans = Undefined function or variable 'aaa'.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Как нетрудно заметить, на этот раз ошибка в вычислении 5/0 не выводится, а значение lasterr осталось тем, что было изначально.
</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="31"></a>Создание 
  паузы в вычислениях</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Для остановки программы используется оператор pause. Он используется в следующих формах:
</font>
</P>
<ul>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> pause — останавливает вычисления до нажатия любой клавиши;&nbsp;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3">pause(N) — останавливает вычисления на N секунд;&nbsp;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> pause on — включает режим отработки пауз;&nbsp;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> pause off — выключает режим отработки пауз.&nbsp;
</font>
  </li>
</ul>
<p align="left">
<font face="Times New Roman" size="3"> Следующий пример поясняет применение команды
pause:
</font>
</p>
<P align="left">
<font face="Courier New" size="3">for 1=1:20;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">х - rand(l,40);
</font>
</P>
<P align="left">
<font face="Courier New" size="3">у - rand(l,40);</font>
</P>
<P align="left">
<font face="Courier New" size="3">z = sin(x.*y);</font>
</P>
<P align="left">
<font face="Courier New" size="3">tri = delaunay(x.y):;
</font>
</P>
<P align="left">
<font face="Courier New" size="3">trisurf(tri.x,y,z)
</font>
</P>
<P align="left">
<font face="Courier New" size="3">paused);
</font>
</P>
<P align="left">
<font face="Courier New" size="3">end
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Команда paused) здесь обеспечивает показ 20 рисунков — построений трехмерных поверхностей из треугольных окрашенных областей со случайными параметрами.
</font>
</P>
<P align="left"> <B><font face="Times New Roman" size="4"><a name="32"></a>Понятие 
  об объектно-ориентированном программировании</font></B> </P>
<P align="left">
<font face="Times New Roman" size="3">Мы уже много раз упоминали различные <I>объекты </I>языка программирования системы MATLAB. Это является одним из признаков <I>объектно-ориентированного программирования </I>(ООП), причем чисто внешним. В основе объектно-ориентированного программирования лежат три основных положения.
</font>
</P>
<ul>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> <I>Инкапсуляция — </I>объединение данных и программ и передача данных через входные и выходные параметры функций. В результате появляется новый элемент программирования — <I>объект.</I>
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> <I>Наследование </I>— возможность создания родительских объектов и новых дочерних объектов, наследующих свойства родительских объектов. Возможно также <I>множественное </I>наследование, при котором класс наследует свойства <I>нескольких </I>родительских объектов. На наследовании основаны система задания типов данных, дескрипторная графика и многие другие приемы программирования. Примеры наследования мы уже неоднократно отмечали.
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> <I>Полиформизм — </I>присвоение некоторому действию одного имени, которое в дальнейшем используется по всей цепочке создаваемых объектов сверху донизу, причем каждый объект выполняет это действие присущим ему способом.
</font>
  </li>
</ul>
<P align="left">
<font face="Times New Roman" size="3">В дополнение к этим положениям объектно-ориентированное программирование в MATLAB допускает <I>агрегирование </I>объектов, т. е., объединение частей объектов или ряда объектов в одно целое.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Объект можно определить как некоторую структуру, принадлежащую к определенному <I>классу. </I>В MATLAB определены следующие семь основных классов объектов:
</font>
</P>
<ul>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> double — числовые массивы с элементами-числами двойной точности;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> sparse — двумерные числовые или комплексные разреженные матрицы;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> char — массивы символов;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> struct — массивы структур (записей);
</font>
  </li>
  <li>
    <p align="left"><font face="Times New Roman" size="3">cell — массивы ячеек;</font></li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3">javaarray <B>— </B> массивы Ява;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> functionjnandle — дескрипторы функций.
</font>
  </li>
</ul>
<P align="left">
<font face="Times New Roman" size="3">С объектами этих классов мы многократно встречались, особо не оговаривая их принадлежность к объектно-ориентированному программированию. Для MATLAB вообще характерно, что никакие классы объектов (в том числе заново создаваемые) не требуют объявления. Например, создавая переменную nаmе='Иван', мы автоматически получаем объект в виде переменной name класса char. Таким образом, для переменных принадлежность к тому или иному классу определяется их значением. Является ли переменная объектом, можно определить при помощи функции isobject(HMfl переменной). Аналогичная функция isjava определяет, является ли переменная объектом
Java.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Для создания новых классов объектов служат <I>конструкторы классов. </I>По существу, это m-файлы, имена которых совпадают с именами классов @Имя_класса, но без символа @. Этим символом помечаются подпапки системы MATLAB, в которых имеются конструкторы классов. Множество таких папок с примерами конструкторов классов вы найдете в подпапках MATLAB\TOOLBOX.<BR>
В качестве примера рассмотрим поддиректорию @SYM в директории TOOLBOX\ SYMBOLIC. В этой поддиректории можно найти конструкторы для более чем сотни объектов пакета символьной математики. К примеру, конструктор функции, вычисляющей арктангенс, выглядит следующим образом:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; help @sym/atan.m&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ATAN   Symbolic inverse tangent.&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo; type @sym/atan,m
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&nbsp;function Y = atan(X)&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> %ATAN   Symbolic inverse tangent.&nbsp;
</font>
</P>
<P align="left">
 <I>
<font face="Courier New" size="3">%
</font>
 </I>
<font face="Courier New" size="3">Copyright (c) 1993-98 by The MathWorks. Inc.&nbsp;
</font>
</P>
<P align="left">
 <I>
<font face="Courier New" size="3">%
</font>
 </I>
<font face="Courier New" size="3">SRevision: 1.10 $ $Date: 1997/11/29 01:05:16 $&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> Y - mapleCmap' ,'atan' .X);</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">В данном случае для конструирования нужного объекта используется функция mapl e, дающая вход в ядро системы символьной математики Maple V R4, которое поставляется в составе системы MATLAB по лицензии фирмы MapleSoft, Inc. Этот пример, кстати, наглядно показывает, что пользователь системы MATLAB может существенно расширить число объектов класса sym, поскольку ядро системы Maple V содержит намного больше определений, чем пакет символьной математики системы MATLAB. Для создания новых классов объектов служит функция class, описанная ниже.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Итак, объектно-ориентированное программирование — это как бы кинжал, закрепленный на вашем поясе. Вы можете и не воспользоваться этим оружием, ощущая при этом его значимость и ценя красоту. Но в альтернативном варианте вы можете использовать его во время ежедневной трапезы в качестве столь необходимого столового ножа. В первом случае вы выступаете в качестве обычного пользователя, а во втором — программиста-профессионала.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Пакеты прикладных программ системы MATLAB позволяют разработчикам с большим успехом использовать возможности объектно-ориентированного программирования путем создания новых классов и объектов. М-файлы системы представляют собой массу наглядных примеров объектно-ориентированного программирования на языке MATLAB. Это дает основание ограничиться справочным описанием основных средств такого программирования с приведением минимума простых примеров.
</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="33"></a>Создание 
  класса или объекта</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Для создания класса объектов или объектов, а также для их идентификации служит функция class. Формы ее применения представлены ниже.
</font>
</P>
<ul>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> class (OBJ) — возвращает класс указанного объекта OBJ. Типы стандартных классов double, sparse, char, cell, struct, functionjiandle были перечислены выше. int8 — 8-разрядный массив целых чисел со знаком; uintS — 8-разрядный массив целых чисел без знака; intlG — 16-разрядный массив целых чисел со знаком; uint!6 — 16-разрядный массив целых чисел без знака; int32 — 32-разрядный массив целых чисел со знаком; uint32 — 32-разрядный массив целых чисел без знака; &lt;class_name&gt; — класс, определенный пользователем; &lt;java_class&gt; — имя класса Ява;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3">OBJ=class(S, 'classjiame' ,PARENT1,PARENT2....) — создает объект класса 'classname' на базе структуры S и родительских объектов PARENT1, PARENT2,... При этом создаваемый объект наследует структуру и поля родительских объектов. Объекту OBJ в данном случае присуще <I>множественное наследование;</I>
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3">OBJ=class(struct[ ]. 'classjiame' .PARENT1.PARENT2,...) — не может иметь никаких полей, кроме унаследованных от родительских объектов.
</font>
  </li>
</ul>
<P align="left">
<font face="Times New Roman" size="3">Обратите внимание на то, что эта функция обычно используется в составе
m-файлов конструкторов классов объектов.
</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="34"></a>Проверка 
  принадлежности объекта к заданному классу</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Для контроля принадлежности заданного объекта к некоторому классу служит функция
isa:
</font>
</P>
<ul>
  <li>
    <p align="left">
<font face="Times New Roman" size="3">isa(OBJ. 'Имя_класса') — возвращает логическую 1, если OBJ принадлежит классу с указанным именем. Дополнительно к вышеописанным выделяет классы numeric и single. Но не обнаруживает класс logical. Нужно использовать функцию islogical, чтобы проверить принадлежность к этому классу.
</font>
  </li>
</ul>
<P align="left">
<font face="Times New Roman" size="3">Примеры применения этой функции:
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; Х=[1 2 3];&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> &raquo; isa(X.'char')&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">0
</font>
</P>
<P align="left">
<font face="Courier New" size="3">&raquo; isa(X,'double')&nbsp;
</font>
</P>
<P align="left">
<font face="Courier New" size="3"> ans =
</font>
</P>
<P align="left">
<font face="Courier New" size="3">1
</font>
</P>
<P align="left"> <font face="Times New Roman" size="4"><a name="35"></a>Другие 
  функции объектно-ориентированного программирования</font> </P>
<P align="left">
<font face="Times New Roman" size="3">Для получения списка методов данного класса объектов сейчас чаще используются функции methodsview и methods. Отличиями от what имя класса является то, что эти функции возвращают информацию также и о классах Java, но информация выводится в отдельном окне, не сообщается информация о папках, все методы из всех папок собраны вместе, и повторяющиеся имена методов удалены:
</font>
</P>
<ul>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> methodsview имя класса или methods имя класса -full — в отдельном окне возвращают полное описание методов класса, включая информацию о наследовании, а для классов Java — и о подписях и атрибутах;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3">M=methods ('имя класса',' -full ') — возвращает ту же информацию в массиве ячеек М;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3">M=methods(' имя класса ') — возвращает массив ячеек с перечислением методов, относящихся к заданному классу объектов;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3">methods имя класса возвращает перечень методов в отдельном окне. Пример:
</font>
  </li>
</ul>
<P align="left">
<font face="Courier New" size="3">&raquo; methods char Methods for class char: delete diff int
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Следующие две функции могут использоваться только внутри конструкторов классов:</font>
</P>
<P align="left">
<font face="Courier New" size="3">inferiorto (' CLASS1'. 'CLASS2'....) и superiortot 'CLASS1', 'CLASS2'....)</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Они определяют низший и высший приоритеты классов по отношению к классу конструктора. Для дескрипторов перегружаемых функций существует функция
</font>
</P>
<P align="left">
<font face="Courier New" size="3">functions</font>
</P>
<P align="left">
<font face="Courier New" size="3">F=functions(дескриптор функции),
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">возвращающая массив структур F. METHODS, вложенный в массив F, при этом именем поля в массиве F. METHODS является имя класса, а значением поля — название метода, который вызывается тогда, когда входной аргумент принадлежит этому классу.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">Дополнительно functions возвращает следующие поля: F.function — строка, используемая для создания дескриптора функция (существуют также отдельная функция func2str для получения этой информации и обратная ей функция str2func, превращающая строку в дескриптор функции); F.type содержит simple (простая), overloaded (перегружаемая) или subfunction (подфункция), т. е. указывает тип</font>
<font face="Times New Roman" size="3">функции; F.default указывает путь к тому файлу, который первый в алгоритме поиска MATLAB и не определен никаким классом.</font>
</P>
<ul>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> which имя метода — находит загруженный Java класс и все классы MATLAB, которым принадлежит данный метод;
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3">&nbsp;which -all имя метода — находит все классы, которым принадлежит данный метод.
</font>
  </li>
</ul>
<P align="left">
<font face="Times New Roman" size="3">Любой оператор в системе MATLAB можно <I>переопределить </I>(т. е. сделать его функцию перегружаемой) путем задания m-файла с новым именем в соответствующем каталоге классов. В частности, в уроке 8 отмечалось, что все арифметические операторы имеют представления в виде соответствующих функций.
</font>
</P>
<P align="left">
<font face="Times New Roman" size="3">При написании книги не ставилась цель детального знакомства с техникой объектно-ориентированного программирования. Дополнительные сведения имеются в книге, содержащей перевод фирменного описания раздела по объектно-ориентированному программированию. Поэтому ограничимся приведенным выше справочным описанием его средств.
</font>
</P>
<P align="left"> <B><font face="Times New Roman" size="4"><a name="36"></a>Что 
  нового мы узнали?</font></B> </P>
<P align="left">
<font face="Times New Roman" size="3">В этом уроке мы научились:
</font>
</P>
<ul>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> Разбираться в видах программирования и его особенностях для MATLAB.
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> Использовать М-файлы сценариев и функций.
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> Выводить сообщения об ошибках и обрабатывать ошибки.
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> Создавать функции с переменным числом аргументов.
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> Использовать комментарии.
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> Создавать Р-коды.
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> Использовать управляющие структуры и функции диалога.
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3">Применять условные операторы, циклы и переключатели.
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> Задавать паузы в вычислениях.
</font>
  </li>
  <li>
    <p align="left">
<font face="Times New Roman" size="3"> Использовать некоторые возможности объектно-ориентированного программирования.
</font>
  </li>
</ul>
</BODY>
</HTML>

